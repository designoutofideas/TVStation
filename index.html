<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TVStation</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Bebas+Neue&family=IBM+Plex+Mono:wght@300;400;600&display=swap');
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  :root{--amber:#ffb700;--dim:#7a5800;--mid:#c87f00;--red:#ff3b1f}
  html,body{width:100%;height:100%;background:#000;color:var(--amber);font-family:'Share Tech Mono',monospace;overflow:hidden}
  body::before{content:'';position:fixed;inset:0;z-index:100;background:repeating-linear-gradient(0deg,rgba(0,0,0,0.15) 0px,rgba(0,0,0,0.15) 1px,transparent 1px,transparent 3px);pointer-events:none}
  body::after{content:'';position:fixed;inset:0;z-index:99;background:radial-gradient(ellipse at center,transparent 50%,rgba(0,0,0,0.88) 100%);pointer-events:none}
  #screen{position:fixed;inset:0;background:#000}
  #player{width:100%;height:100%;object-fit:contain;display:block}
  #hud{position:fixed;inset:0;z-index:90;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:24px 32px}
  .hud-top{display:flex;justify-content:space-between;align-items:flex-start}
  .sid{font-family:'Bebas Neue',cursive;font-size:clamp(26px,4vw,50px);letter-spacing:.12em;color:var(--amber);text-shadow:0 0 20px var(--amber),0 0 40px rgba(255,183,0,.3);line-height:1}
  .ssub{font-family:'IBM Plex Mono',monospace;font-size:9px;font-weight:300;letter-spacing:.35em;color:var(--dim);display:block;margin-top:5px}
  .live{display:flex;align-items:center;gap:7px;margin-top:10px;font-family:'IBM Plex Mono',monospace;font-size:10px;font-weight:600;letter-spacing:.22em;color:var(--red);text-shadow:0 0 10px var(--red)}
  .dot{width:7px;height:7px;border-radius:50%;background:var(--red);box-shadow:0 0 8px var(--red);animation:blink 1.4s ease-in-out infinite}
  @keyframes blink{0%,100%{opacity:1}50%{opacity:.15}}
  .clk{text-align:right}
  #clock{font-family:'Bebas Neue',cursive;font-size:clamp(20px,3vw,40px);letter-spacing:.08em;color:var(--amber);text-shadow:0 0 14px var(--amber);display:block}
  #dateline{font-family:'IBM Plex Mono',monospace;font-size:9px;letter-spacing:.22em;color:var(--dim);margin-top:3px}
  .hud-bot{display:flex;flex-direction:column;gap:8px}
  .ptrack{width:100%;height:2px;background:rgba(255,183,0,.1)}
  #pfill{height:100%;background:var(--amber);box-shadow:0 0 6px var(--amber);width:0%;transition:width .95s linear}
  .irow{display:flex;justify-content:space-between;align-items:flex-end;gap:16px}
  .ncol{flex:1;min-width:0}
  .lbl{font-family:'IBM Plex Mono',monospace;font-size:8px;font-weight:600;letter-spacing:.32em;color:var(--dim);text-transform:uppercase;margin-bottom:5px}
  #now-title{font-family:'Bebas Neue',cursive;font-size:clamp(16px,2.6vw,36px);letter-spacing:.06em;color:var(--amber);text-shadow:0 0 18px rgba(255,183,0,.4);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:62vw}
  #genre{display:inline-block;font-family:'IBM Plex Mono',monospace;font-size:8px;font-weight:600;letter-spacing:.22em;color:#000;background:var(--dim);padding:2px 7px;margin-top:5px}
  .xcol{text-align:right;min-width:180px;max-width:260px}
  #next-title{font-family:'IBM Plex Mono',monospace;font-size:10px;font-weight:300;color:rgba(255,183,0,.4);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #tleft{font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--dim);margin-top:3px}
  #flash{position:fixed;inset:0;z-index:95;background:#fff;opacity:0;pointer-events:none;transition:opacity .04s}
  #flash.on{opacity:.4}
  #overlay{position:fixed;inset:0;z-index:300;background:rgba(0,0,0,.92);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;cursor:pointer}
  #olab{font-family:'Bebas Neue',cursive;font-size:clamp(40px,8vw,96px);letter-spacing:.1em;color:var(--amber);text-shadow:0 0 40px var(--amber),0 0 80px rgba(255,183,0,.25);text-align:center;line-height:1}
  #osub{font-family:'IBM Plex Mono',monospace;font-size:11px;letter-spacing:.28em;color:var(--dim);text-align:center}
  #ostat{font-family:'IBM Plex Mono',monospace;font-size:9px;letter-spacing:.2em;color:var(--dim);text-align:center;margin-top:4px;min-height:14px}
  #err{position:fixed;inset:0;z-index:200;display:none;flex-direction:column;align-items:center;justify-content:center;gap:16px;text-align:center;padding:40px}
  #err.show{display:flex}
  #err h1{font-family:'Bebas Neue',cursive;font-size:clamp(28px,5vw,60px);letter-spacing:.1em;color:var(--dim)}
  #err p{font-family:'IBM Plex Mono',monospace;font-size:10px;letter-spacing:.18em;color:var(--dim);line-height:2;max-width:440px}
  #err a{font-family:'IBM Plex Mono',monospace;font-size:10px;letter-spacing:.2em;color:var(--amber);text-decoration:none;border:1px solid var(--dim);padding:9px 20px}
</style>
</head>
<body>

<div id="screen">
  <video id="player" playsinline preload="auto"></video>
</div>

<div id="hud">
  <div class="hud-top">
    <div>
      <div class="sid">TVStation<span class="ssub">BROADCASTING 24 / 7</span></div>
      <div class="live"><div class="dot"></div>LIVE</div>
    </div>
    <div class="clk">
      <span id="clock">00:00:00</span>
      <div id="dateline"></div>
    </div>
  </div>
  <div class="hud-bot">
    <div class="ptrack"><div id="pfill"></div></div>
    <div class="irow">
      <div class="ncol">
        <div class="lbl">Now Playing</div>
        <div id="now-title">—</div>
        <div id="genre">—</div>
      </div>
      <div class="xcol">
        <div class="lbl" style="text-align:right">Up Next</div>
        <div id="next-title">—</div>
        <div id="tleft">—</div>
      </div>
    </div>
  </div>
</div>

<div id="flash"></div>

<div id="overlay" onclick="tuneIn()">
  <div id="olab">&#9654; CLICK TO<br>TUNE IN</div>
  <div id="osub">TVStation &middot; 24/7 Live Broadcast</div>
  <div id="ostat">CONTACTING BROADCAST SERVER&hellip;</div>
</div>

<div id="err">
  <h1>NO SIGNAL</h1>
  <p>Could not reach the broadcast server.<br>Check that your Cloudflare Worker is deployed<br>and WORKER_URL is set correctly in index.html.</p>
  <a href="admin.html">OPEN ADMIN &rarr;</a>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
//  TVStation — Thin Client  v4
//
//  This page does NOT manage the schedule. It asks the Cloudflare
//  Worker (master clock) what is playing RIGHT NOW, then:
//    1. Loads that video
//    2. Seeks to the exact second
//    3. Polls the worker every ~10s to stay in sync
//    4. On slot end, fetches next slot and cuts immediately
//
//  Every browser tuning in at the same moment sees the same frame.
// ═══════════════════════════════════════════════════════════════

// !! REPLACE THIS with your Cloudflare Worker URL after deploying !!
const WORKER_URL = 'https://square-night-4e81.demo-3b5.workers.dev/';

const player    = document.getElementById('player');
const clockEl   = document.getElementById('clock');
const dateEl    = document.getElementById('dateline');
const nowTitleEl= document.getElementById('now-title');
const genreEl   = document.getElementById('genre');
const nextTitleEl=document.getElementById('next-title');
const tleftEl   = document.getElementById('tleft');
const pfillEl   = document.getElementById('pfill');
const flashEl   = document.getElementById('flash');
const overlayEl = document.getElementById('overlay');
const ostatEl   = document.getElementById('ostat');
const errEl     = document.getElementById('err');

// State
let current     = null;   // current slot info from worker
let clockOffset = 0;      // ms difference between server UTC and local Date.now()
let tickInterval = null;
let syncInterval = null;
let userClicked  = false;
let workerReady  = false;

// ── CLOCK ──────────────────────────────────────────────────────
const DN=['SUN','MON','TUE','WED','THU','FRI','SAT'];
const MN=['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];

// Corrected wall time in seconds using server clock offset
function wallSec() {
  const ms = Date.now() + clockOffset;
  const d  = new Date(ms);
  return d.getUTCHours()*3600 + d.getUTCMinutes()*60 + d.getUTCSeconds()
       + d.getUTCMilliseconds()/1000;
}

function tickClock() {
  // Use viewer's local time for the display clock
  // (schedule sync stays on UTC — this is display only)
  const d = new Date();
  const p = n => String(n).padStart(2,'0');
  clockEl.textContent = p(d.getHours())+':'+p(d.getMinutes())+':'+p(d.getSeconds());
  dateEl.textContent  = DN[d.getDay()]+' '+d.getDate()+' '+MN[d.getMonth()]+' '+d.getFullYear();
}
setInterval(tickClock, 1000);
tickClock();

// ── WORKER SYNC ────────────────────────────────────────────────
async function fetchBroadcast() {
  const t0 = Date.now();
  try {
    const r = await fetch(WORKER_URL + '?_=' + t0, { cache: 'no-store' });
    if (!r.ok) throw new Error('worker HTTP ' + r.status);
    const data = await r.json();
    const rtt  = Date.now() - t0;

    // Calibrate local clock to server UTC (account for ~half RTT)
    clockOffset = (data.serverMs - (t0 + rtt/2));

    workerReady = true;
    ostatEl.textContent = 'BROADCAST READY — CLICK TO TUNE IN';
    ostatEl.style.color = '#ffb700';

    return data;
  } catch(e) {
    console.error('Worker fetch failed:', e.message);
    ostatEl.textContent = 'SERVER UNAVAILABLE — ' + e.message;
    return null;
  }
}

// ── TUNE IN ────────────────────────────────────────────────────
async function tuneIn() {
  if (!workerReady) return; // not ready yet
  userClicked = true;
  overlayEl.style.display = 'none';

  const data = await fetchBroadcast();
  if (!data) { showErr(); return; }

  current = data;

  // Pre-warm metadata URLs for current AND next item in parallel
  // so loadSlot() finds them instantly in metaCache
  await Promise.all([
    resolveMetaUrl(data.identifier),
    data.next && data.next.identifier ? resolveMetaUrl(data.next.identifier) : Promise.resolve()
  ]);

  await loadSlot(data, true);

  updateHUD();

  // Tick every 500ms for HUD + slot transition detection
  if (tickInterval) clearInterval(tickInterval);
  tickInterval = setInterval(broadcastTick, 500);

  // Re-sync with worker every 15 seconds to correct any drift
  if (syncInterval) clearInterval(syncInterval);
  syncInterval = setInterval(resync, 15000);
}

// ── LOAD A SLOT ────────────────────────────────────────────────
async function loadSlot(data, seekLive) {
  const offset = seekLive ? Math.max(0, data.seekTo) : 0;

  // Always resolve the real URL via Archive.org metadata API first.
  // This guarantees the correct filename regardless of what the worker guesses.
  let url = await resolveMetaUrl(data.identifier);

  // If metadata lookup fails, fall back to worker's URL
  if (!url) url = data.streamUrl;
  if (!url) { console.warn('No URL for', data.identifier); return; }

  if (player.src !== url) {
    player.src = url;
    player.load();
  }

  return new Promise(resolve => {
    const doSeekPlay = () => {
      if (seekLive && offset > 2) {
        const dur = player.duration;
        const t   = isFinite(dur) ? Math.min(offset, dur - 1) : offset;
        if (t > 0) player.currentTime = t;
      }
      player.play().then(resolve).catch(e => {
        console.warn('play() failed:', e.message);
        resolve();
      });
    };

    if (player.readyState >= 1) doSeekPlay();
    else {
      player.onloadedmetadata = () => { player.onloadedmetadata = null; doSeekPlay(); };
    }
  });
}

// Metadata fallback (same as before)
const metaCache = {};
async function resolveMetaUrl(identifier) {
  if (!identifier) return null;
  if (metaCache[identifier]) return metaCache[identifier];
  try {
    const r    = await fetch('https://archive.org/metadata/' + identifier);
    const meta = await r.json();
    const files= meta.files || [];
    const order= [
      f => /\.ia\.mp4$/i.test(f.name),
      f => /_512kb\.mp4$/i.test(f.name) && f.source === 'derivative',
      f => /\.mp4$/i.test(f.name)       && f.source === 'derivative',
      f => /_512kb\.mp4$/i.test(f.name),
      f => /\.mp4$/i.test(f.name),
      f => /\.ogv$/i.test(f.name),
      f => /\.webm$/i.test(f.name),
    ];
    let picked = null;
    for (const fn of order) { picked = files.find(fn); if (picked) break; }
    if (picked) {
      const url = 'https://archive.org/download/'+identifier+'/'+encodeURIComponent(picked.name);
      metaCache[identifier] = url;
      return url;
    }
  } catch(e) { console.warn('meta fallback failed:', identifier); }
  return null;
}

// ── BROADCAST TICK ────────────────────────────────────────────
function broadcastTick() {
  if (!current || !userClicked) return;
  updateHUD();

  // Has the current slot ended by wall clock?
  const now = wallSec();
  if (now >= current.slotEnd) {
    cutToNext();
  }
}

async function cutToNext() {
  clearInterval(tickInterval);
  flashEl.classList.add('on');
  setTimeout(() => flashEl.classList.remove('on'), 60);
  player.pause();

  const data = await fetchBroadcast();
  if (!data) { setTimeout(cutToNext, 2000); return; }
  current = data;
  // Pre-warm next item's URL while current plays
  if (data.next && data.next.identifier) resolveMetaUrl(data.next.identifier);
  await loadSlot(data, false); // don't seek — start from beginning of slot
  updateHUD();

  tickInterval = setInterval(broadcastTick, 500);
}

// Periodic re-sync: correct clock drift and seek correction
async function resync() {
  if (!current || !userClicked) return;
  const data = await fetchBroadcast();
  if (!data) return;

  // If we're now in a different slot, cut to it
  if (data.identifier !== current.identifier || data.slotStart !== current.slotStart) {
    current = data;
    flashEl.classList.add('on');
    setTimeout(() => flashEl.classList.remove('on'), 60);
    player.pause();
    await loadSlot(data, true);
    updateHUD();
    return;
  }

  // Same slot — check we're within 3 seconds of correct position
  const expected = data.seekTo;
  const actual   = player.currentTime;
  if (Math.abs(actual - expected) > 3) {
    console.log('Drift correction:', actual, '→', expected);
    player.currentTime = expected;
  }

  current = data;
}

// ── HUD UPDATE ─────────────────────────────────────────────────
function updateHUD() {
  if (!current) return;
  const now     = wallSec();
  const elapsed = Math.max(0, now - current.slotStart);
  const total   = current.slotDuration || 1;
  const pct     = Math.min(100, (elapsed / total) * 100);
  pfillEl.style.width = pct + '%';

  nowTitleEl.textContent = current.title  || '—';
  genreEl.textContent    = (current.blockName || current.genre || 'BROADCAST').toUpperCase();
  nextTitleEl.textContent= (current.next && current.next.title) || '—';

  const secLeft = Math.max(0, Math.round(current.slotEnd - now));
  const mm = Math.floor(secLeft/60), ss = String(secLeft%60).padStart(2,'0');
  tleftEl.textContent = 'in ' + mm + ':' + ss;
}

// ── PLAYER EVENTS ──────────────────────────────────────────────
// Video file ends before slot does (duration mismatch) — cut immediately
player.addEventListener('ended', () => {
  if (!userClicked) return;
  cutToNext();
});

player.addEventListener('error', () => {
  if (!userClicked) return;
  console.warn('Player error');
  setTimeout(cutToNext, 800);
});

function showErr() {
  errEl.classList.add('show');
}

// ── INIT ───────────────────────────────────────────────────────
// Start fetching from worker immediately so it's ready by the time user clicks
fetchBroadcast().then(data => {
  if (!data) {
    ostatEl.textContent = 'CANNOT REACH BROADCAST SERVER';
    ostatEl.style.color = '#ff3b1f';
    // Show error if worker URL hasn't been set
    if (WORKER_URL.includes('YOUR-SUBDOMAIN')) {
      ostatEl.textContent = 'SET WORKER_URL IN INDEX.HTML FIRST';
      ostatEl.style.color = '#ff3b1f';
    }
  }
});
</script>
</body>
</html>
