<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TVStation</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Bebas+Neue&family=IBM+Plex+Mono:wght@300;400;600&display=swap');
  *,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
  :root{--amber:#ffb700;--amber-dim:#7a5800;--amber-mid:#c87f00;--red:#ff3b1f;--bg:#000}
  html,body{width:100%;height:100%;background:#000;color:var(--amber);font-family:'Share Tech Mono',monospace;overflow:hidden}
  body::before{content:'';position:fixed;inset:0;z-index:100;background:repeating-linear-gradient(0deg,rgba(0,0,0,0.15) 0px,rgba(0,0,0,0.15) 1px,transparent 1px,transparent 3px);pointer-events:none}
  body::after{content:'';position:fixed;inset:0;z-index:99;background:radial-gradient(ellipse at center,transparent 50%,rgba(0,0,0,0.88) 100%);pointer-events:none}
  #screen{position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center}
  #player{width:100%;height:100%;object-fit:contain;display:block}
  #hud{position:fixed;inset:0;z-index:90;pointer-events:none;display:flex;flex-direction:column;justify-content:space-between;padding:24px 32px}
  .hud-top{display:flex;justify-content:space-between;align-items:flex-start}
  .station-id{font-family:'Bebas Neue',cursive;font-size:clamp(26px,4vw,50px);letter-spacing:.12em;color:var(--amber);text-shadow:0 0 20px var(--amber),0 0 40px rgba(255,183,0,.3);line-height:1}
  .station-sub{font-family:'IBM Plex Mono',monospace;font-size:9px;font-weight:300;letter-spacing:.35em;color:var(--amber-dim);display:block;margin-top:5px}
  .live-row{display:flex;align-items:center;gap:7px;margin-top:10px;font-family:'IBM Plex Mono',monospace;font-size:10px;font-weight:600;letter-spacing:.22em;color:var(--red);text-shadow:0 0 10px var(--red)}
  .live-dot{width:7px;height:7px;border-radius:50%;background:var(--red);box-shadow:0 0 8px var(--red);animation:blink 1.4s ease-in-out infinite}
  @keyframes blink{0%,100%{opacity:1}50%{opacity:.15}}
  .clock-col{text-align:right}
  #clock{font-family:'Bebas Neue',cursive;font-size:clamp(20px,3vw,40px);letter-spacing:.08em;color:var(--amber);text-shadow:0 0 14px var(--amber);display:block}
  #dateline{font-family:'IBM Plex Mono',monospace;font-size:9px;letter-spacing:.22em;color:var(--amber-dim);margin-top:3px}
  .hud-bottom{display:flex;flex-direction:column;gap:8px}
  .progress-track{width:100%;height:2px;background:rgba(255,183,0,.1)}
  #progress-fill{height:100%;background:var(--amber);box-shadow:0 0 6px var(--amber);width:0%;transition:width .9s linear}
  .info-row{display:flex;justify-content:space-between;align-items:flex-end;gap:16px}
  .now-col{flex:1;min-width:0}
  .tag{font-family:'IBM Plex Mono',monospace;font-size:8px;font-weight:600;letter-spacing:.32em;color:var(--amber-dim);text-transform:uppercase;margin-bottom:5px}
  #now-title{font-family:'Bebas Neue',cursive;font-size:clamp(16px,2.6vw,36px);letter-spacing:.06em;color:var(--amber);text-shadow:0 0 18px rgba(255,183,0,.4);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:62vw}
  #genre-badge{display:inline-block;font-family:'IBM Plex Mono',monospace;font-size:8px;font-weight:600;letter-spacing:.22em;color:#000;background:var(--amber-dim);padding:2px 7px;margin-top:5px}
  .next-col{text-align:right;min-width:180px;max-width:260px}
  #next-title{font-family:'IBM Plex Mono',monospace;font-size:10px;font-weight:300;color:rgba(255,183,0,.4);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  #time-left{font-family:'IBM Plex Mono',monospace;font-size:9px;color:var(--amber-dim);margin-top:3px}
  #cut-flash{position:fixed;inset:0;z-index:95;background:#fff;opacity:0;pointer-events:none;transition:opacity .04s}
  #cut-flash.on{opacity:.45}
  #tunein{position:fixed;inset:0;z-index:300;background:rgba(0,0,0,.92);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:20px;cursor:pointer}
  #tunein-label{font-family:'Bebas Neue',cursive;font-size:clamp(40px,8vw,96px);letter-spacing:.1em;color:var(--amber);text-shadow:0 0 40px var(--amber),0 0 80px rgba(255,183,0,.25);text-align:center;line-height:1}
  #tunein-sub{font-family:'IBM Plex Mono',monospace;font-size:11px;letter-spacing:.28em;color:var(--amber-dim);text-align:center}
  #no-sched{position:fixed;inset:0;z-index:200;display:none;flex-direction:column;align-items:center;justify-content:center;gap:20px;text-align:center;padding:40px}
  #no-sched.show{display:flex}
  #no-sched h1{font-family:'Bebas Neue',cursive;font-size:clamp(32px,6vw,72px);letter-spacing:.1em;color:var(--amber);text-shadow:0 0 30px var(--amber)}
  #no-sched p{font-family:'IBM Plex Mono',monospace;font-size:11px;letter-spacing:.18em;color:var(--amber-dim);line-height:1.9;max-width:480px}
  #no-sched a{font-family:'IBM Plex Mono',monospace;font-size:10px;letter-spacing:.2em;color:var(--amber);text-decoration:none;border:1px solid var(--amber-dim);padding:10px 22px}
</style>
</head>
<body>

<div id="screen">
  <video id="player" playsinline preload="auto"></video>
</div>

<div id="hud">
  <div class="hud-top">
    <div>
      <div class="station-id">TVStation<span class="station-sub">BROADCASTING 24 / 7</span></div>
      <div class="live-row"><div class="live-dot"></div>LIVE</div>
    </div>
    <div class="clock-col">
      <span id="clock">00:00:00</span>
      <div id="dateline"></div>
    </div>
  </div>
  <div class="hud-bottom">
    <div class="progress-track"><div id="progress-fill"></div></div>
    <div class="info-row">
      <div class="now-col">
        <div class="tag">Now Playing</div>
        <div id="now-title">—</div>
        <div id="genre-badge">—</div>
      </div>
      <div class="next-col">
        <div class="tag" style="text-align:right">Up Next</div>
        <div id="next-title">—</div>
        <div id="time-left">—</div>
      </div>
    </div>
  </div>
</div>

<div id="cut-flash"></div>

<div id="tunein" onclick="tuneIn()">
  <div id="tunein-label">&#9654; CLICK TO<br>TUNE IN</div>
  <div id="tunein-sub">TVStation &middot; 24/7 Live Broadcast</div>
</div>

<div id="no-sched">
  <h1>TVStation</h1>
  <p>NO SCHEDULE FOUND<br>CREATE ONE USING THE ADMIN PANEL</p>
  <a href="admin.html">OPEN ADMIN &rarr;</a>
</div>

<script>
const SCHEDULE_URL = './schedule.json';
const DAY = 86400;

// DOM
const player     = document.getElementById('player');
const clockEl    = document.getElementById('clock');
const dateEl     = document.getElementById('dateline');
const nowTitleEl = document.getElementById('now-title');
const genreEl    = document.getElementById('genre-badge');
const nextTitleEl= document.getElementById('next-title');
const timeLeftEl = document.getElementById('time-left');
const progressEl = document.getElementById('progress-fill');
const flashEl    = document.getElementById('cut-flash');
const tuneinEl   = document.getElementById('tunein');
const noSchedEl  = document.getElementById('no-sched');

// State
let timeline      = [];
let urlCache      = {};
let currentIdx    = -1;
let tickInterval  = null;
let userClicked   = false;
let scheduleReady = false;

// ── CLOCK ─────────────────────────────────────────────────────
const DNAMES  = ['SUN','MON','TUE','WED','THU','FRI','SAT'];
const MNAMES  = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
function wallSec() {
  const d = new Date();
  return d.getHours()*3600 + d.getMinutes()*60 + d.getSeconds() + d.getMilliseconds()/1000;
}
function tickClock() {
  const d = new Date(), p = n => String(n).padStart(2,'0');
  clockEl.textContent = p(d.getHours())+':'+p(d.getMinutes())+':'+p(d.getSeconds());
  dateEl.textContent  = DNAMES[d.getDay()]+' '+d.getDate()+' '+MNAMES[d.getMonth()]+' '+d.getFullYear();
}
setInterval(tickClock,1000); tickClock();

// ── SCHEDULE ──────────────────────────────────────────────────
async function loadSchedule() {
  try {
    const r = await fetch(SCHEDULE_URL+'?_='+Date.now());
    if (!r.ok) throw new Error('not found');
    const data = await r.json();
    const tl = buildTimeline(data);
    if (!tl.length) throw new Error('empty');
    timeline = tl;
    scheduleReady = true;
    noSchedEl.classList.remove('show');
    if (userClicked) beginBroadcast();
  } catch(e) {
    console.warn('Schedule:', e.message);
    noSchedEl.classList.add('show');
  }
}

function buildTimeline(data) {
  const blocks = (data.blocks||[]).slice().sort((a,b)=>toSec(a.startTime)-toSec(b.startTime));
  const result = [];
  blocks.forEach((block,bi) => {
    const items = (block.items||[]).filter(i => i.identifier||i.url);
    if (!items.length) return;
    const bStart = toSec(block.startTime);
    const bEnd   = bi+1<blocks.length ? toSec(blocks[bi+1].startTime) : DAY;
    let cursor=bStart, i=0;
    while (cursor<bEnd && i<2000) {
      const item = items[i%items.length];
      const dur  = Math.max(10, item.duration||300);
      const end  = Math.min(cursor+dur, bEnd);
      result.push({
        title     : item.title||item.identifier||'—',
        identifier: item.identifier||null,
        url       : item.url||null,
        blockName : block.name,
        genre     : block.genre||block.name,
        startSec  : cursor,
        endSec    : end
      });
      cursor=end; i++;
    }
  });
  return result;
}

function toSec(t) {
  if (!t) return 0;
  if (typeof t==='number') return t;
  const [h,m]=t.split(':').map(Number);
  return (h||0)*3600+(m||0)*60;
}

function idxAt(sec) {
  const s=((sec%DAY)+DAY)%DAY;
  for (let i=0;i<timeline.length;i++)
    if (s>=timeline[i].startSec && s<timeline[i].endSec) return i;
  return 0;
}

// ── URL RESOLUTION ────────────────────────────────────────────
// Instant guess — no network round trip. Archive.org uses this
// naming pattern for the majority of their video derivatives.
function guessUrl(id) {
  return 'https://archive.org/download/'+id+'/'+id+'_512kb.mp4';
}

async function resolveUrl(id) {
  if (urlCache[id]) return urlCache[id];
  try {
    const r    = await fetch('https://archive.org/metadata/'+id);
    if (!r.ok) throw new Error('meta '+r.status);
    const meta = await r.json();
    const files= (meta.files||[]);
    const order= [
      f => /_512kb\.mp4$/i.test(f.name) && f.source==='derivative',
      f => /\.mp4$/i.test(f.name)       && f.source==='derivative',
      f => /_512kb\.mp4$/i.test(f.name),
      f => /\.mp4$/i.test(f.name),
      f => /\.ogv$/i.test(f.name),
      f => /\.webm$/i.test(f.name),
    ];
    let picked=null;
    for (const fn of order) { picked=files.find(fn); if(picked) break; }
    if (!picked) picked=files.find(f=>/\.(mp4|ogv|webm|avi|mov)$/i.test(f.name));
    if (picked) {
      const url='https://archive.org/download/'+id+'/'+encodeURIComponent(picked.name);
      urlCache[id]=url;
      return url;
    }
  } catch(e) { console.warn('resolve failed:',id,e.message); }
  return null;
}

// ── BROADCAST ─────────────────────────────────────────────────
function tuneIn() {
  userClicked=true;
  tuneinEl.style.display='none';
  if (scheduleReady) beginBroadcast();
  // else: loadSchedule() will call beginBroadcast() when ready
}

function beginBroadcast() {
  if (tickInterval) clearInterval(tickInterval);
  const idx=idxAt(wallSec());
  playSlot(idx, true);
  warmNext(idx);
  tickInterval=setInterval(broadcastTick, 800);
}

function broadcastTick() {
  if (!scheduleReady||!userClicked) return;
  const now=wallSec();
  const slot=timeline[currentIdx];
  if (!slot) return;
  // Check wall clock — cut if we've passed slot end
  if (now >= slot.endSec) {
    const ni=idxAt(now);
    if (ni!==currentIdx) doCut(ni);
  }
  updateHUD();
}

async function playSlot(idx, seekLive) {
  if (idx<0||idx>=timeline.length) return;
  currentIdx=idx;
  const slot=timeline[idx];

  // Determine URL — use cache or instant guess
  let url = slot.url
          || (slot.identifier ? urlCache[slot.identifier]||null : null);

  if (!url && slot.identifier) {
    // Use instant guess so playback starts immediately
    url = guessUrl(slot.identifier);
    // Quietly confirm the real URL in background
    resolveUrl(slot.identifier).then(confirmed => {
      if (!confirmed || currentIdx!==idx) return;
      if (confirmed===player.src) { urlCache[slot.identifier]=confirmed; return; }
      // Swap to confirmed URL mid-play, preserving position
      const t = player.currentTime;
      player.src = confirmed;
      player.currentTime = t;
      player.play().catch(()=>{});
    });
  }

  if (!url) {
    console.warn('No URL, skipping slot',idx);
    setTimeout(()=>doCut((idx+1)%timeline.length), 800);
    return;
  }

  const offset = seekLive ? Math.max(0, wallSec()-slot.startSec) : 0;

  // Avoid unnecessary src reload
  if (player.src !== url) {
    player.src = url;
  }

  updateHUD();

  const tryPlay = () => {
    if (seekLive && offset>2) {
      const dur=player.duration;
      const target=isFinite(dur) ? Math.min(offset,dur-1) : offset;
      if (target>0) player.currentTime=target;
    }
    player.play().catch(err => {
      // If the guessed URL 404'd, fall back to metadata lookup immediately
      if (slot.identifier && url===guessUrl(slot.identifier)) {
        resolveUrl(slot.identifier).then(confirmed => {
          if (confirmed && currentIdx===idx) {
            player.src=confirmed;
            if (offset>2) player.currentTime=offset;
            player.play().catch(()=>{});
          } else if (!confirmed) {
            console.warn('Unplayable, skipping:',slot.title);
            doCut((idx+1)%timeline.length);
          }
        });
      }
    });
  };

  if (player.readyState>=1) {
    tryPlay();
  } else {
    player.onloadedmetadata = ()=>{
      player.onloadedmetadata=null;
      tryPlay();
    };
  }
}

function doCut(nextIdx) {
  // Brief channel-change flash
  flashEl.classList.add('on');
  setTimeout(()=>flashEl.classList.remove('on'),60);
  player.pause();
  playSlot(nextIdx, false);
  warmNext(nextIdx);
}

// Pre-warm the next slot's URL into cache so cut is instant
function warmNext(idx) {
  const next=timeline[(idx+1)%timeline.length];
  if (next&&next.identifier&&!urlCache[next.identifier]) {
    resolveUrl(next.identifier).catch(()=>{});
  }
}

// ── HUD ───────────────────────────────────────────────────────
function updateHUD() {
  const slot=timeline[currentIdx];
  if (!slot) return;
  const now=wallSec();
  const pct=Math.max(0,Math.min(100,((now-slot.startSec)/(slot.endSec-slot.startSec))*100));
  progressEl.style.width=pct+'%';
  nowTitleEl.textContent=slot.title;
  genreEl.textContent=(slot.blockName||slot.genre||'BROADCAST').toUpperCase();
  const next=timeline[(currentIdx+1)%timeline.length];
  if (next) {
    nextTitleEl.textContent=next.title;
    const s=Math.max(0,Math.round(slot.endSec-now));
    timeLeftEl.textContent='in '+Math.floor(s/60)+':'+String(s%60).padStart(2,'0');
  }
}

// ── PLAYER EVENTS ─────────────────────────────────────────────
// Video ended before its scheduled slot — cut immediately, no gap
player.addEventListener('ended', ()=>{
  if (!scheduleReady||!userClicked) return;
  const now=wallSec();
  const ni=idxAt(now)===currentIdx ? (currentIdx+1)%timeline.length : idxAt(now);
  doCut(ni);
});

player.addEventListener('error', ()=>{
  if (!scheduleReady||!userClicked) return;
  console.warn('Video error — skipping');
  setTimeout(()=>doCut((currentIdx+1)%timeline.length), 500);
});

// ── INIT ──────────────────────────────────────────────────────
loadSchedule();
setInterval(loadSchedule, 30*60*1000);
</script>
</body>
</html>
